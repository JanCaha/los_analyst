<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>losanalyst.classes.los_global API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>losanalyst.classes.los_global</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from osgeo import ogr
from typing import Union
import math
from losanalyst.classes.los import LoS


class LoSGlobal(LoS):
    &#34;&#34;&#34;
    Class representing global LoS.

    See Also
    --------
    LoS : the basic class for representation of LoS
    &#34;&#34;&#34;

    def __init__(self,
                 points: list,
                 observer_offset: float = 0,
                 target_offset: float = 0,
                 target_x: float = 0,
                 target_y: float = 0,
                 sampling_distance: float = None,
                 use_curvature_corrections: bool = True,
                 refraction_coefficient: float = 0.13):

        super().__init__(points,
                         is_global=True,
                         observer_offset=observer_offset,
                         target_offset=target_offset,
                         target_x=target_x,
                         target_y=target_y,
                         sampling_distance=sampling_distance,
                         use_curvature_corrections=use_curvature_corrections,
                         refraction_coefficient=refraction_coefficient)

        self.global_horizon_index = None

    def get_visible(self, return_integer: bool = False) -&gt; Union[bool, int]:
        &#34;&#34;&#34;
        Is the target point visible?

        Parameters
        ----------
        return_integer : bool, optional
            If the value is `True` returns values `0` or `1`. If it is `False` returns `True` or `False`.

        Returns
        -------
        bool or int
            Visibility of target point.
        &#34;&#34;&#34;

        if return_integer:
            return int(self.visible[self.target_index])
        else:
            return self.visible[self.target_index]

    def _get_global_horizon_index(self) -&gt; int:
        &#34;&#34;&#34;
        Returns index of global horizon from list of points.

        Returns
        -------
        int
            Index of global horizon in `points`. If `0` then no global horizon is found.
        &#34;&#34;&#34;

        if self.global_horizon_index is not None:
            return self.global_horizon_index
        else:
            horizon_index = 0
            for i in range(1, len(self.points) - 1):
                if self.horizon[i] and i != self.target_index:
                    horizon_index = i
            self.global_horizon_index = horizon_index
            return self.global_horizon_index

    def get_angle_difference_global_horizon(self) -&gt; float:
        &#34;&#34;&#34;
        Get angle difference between target point and horizon angle. Positive value means that horizon is lower than
        target point, negative value means that horizon is higher then target point.

        Returns
        -------
        float
            Value of angle difference.
        &#34;&#34;&#34;

        horizon_angle = -90
        if self._get_global_horizon_index() != 0:
            horizon_angle = self.points[self._get_global_horizon_index()][4]
        return self.points[self.target_index][4] - horizon_angle

    def get_elevation_difference_global_horizon(self) -&gt; float:
        &#34;&#34;&#34;
        Get elevation difference between target point and horizon angle. Positive value means that horizon is lower than
        target point and the resulting value have to be added to target point to hide the horizon. Negative value
        means that horizon is higher then target point and it would need to lower by resulting value not to hide the
        horizon.

        Returns
        -------
        float
        &#34;&#34;&#34;

        elev_difference_horizon = self.points[self.target_index][3] - (
                    self.points[0][3] + math.tan(math.radians(self.points[self._get_global_horizon_index()][4])) *
                    self.points[self.target_index][2])
        return elev_difference_horizon

    def get_horizon_distance(self) -&gt; float:
        &#34;&#34;&#34;
        Get distance of the global horizon from observer.

        Returns
        -------
        float
            Distance.
        &#34;&#34;&#34;
        return self.points[self._get_global_horizon_index()][2]

    def get_horizon_count(self) -&gt; int:
        &#34;&#34;&#34;
        Get the number of horizons behind target on LoS.

        Returns
        -------
        int
        &#34;&#34;&#34;
        return int(math.fsum(self.horizon[self.target_index+1:]))

    def __get_global_horizon_index(self) -&gt; int:
        &#34;&#34;&#34;
        Find the global horizon in `horizon`.

        Returns
        -------
        int
            Index in list.
        &#34;&#34;&#34;

        index = None

        for i in range(len(self.points) - 1, -1, -1):
            if self.horizon[i]:
                index = i
                break

        return index

    def get_global_horizon(self) -&gt; ogr.Geometry:
        &#34;&#34;&#34;
        Get global horizon from LoS as `ogr.Geometry` point.

        Returns
        -------
        ogr.Geometry
        &#34;&#34;&#34;
        index = self.__get_global_horizon_index()

        if index is None:
            index = -1

        return self._get_geom_at_index(index)

    def _get_max_local_horizon_index(self) -&gt; int:
        &#34;&#34;&#34;
        Get index of maximal local horizon (between observer and target) from `horizon`.

        Returns
        -------
        int or None
            If the result is `None`, there is no local horizon.
        &#34;&#34;&#34;

        index = None

        for i in range(self.target_index-1, -1, -1):
            if self.horizon[i] and i != self.target_index:
                index = i
                break

        return index

    def get_max_local_horizon(self) -&gt; ogr.Geometry:
        &#34;&#34;&#34;
        Get maximal local horizon from LoS as `ogr.Geometry` point.

        Returns
        -------
        ogr.Geometry
        &#34;&#34;&#34;
        index = self._get_max_local_horizon_index()

        if index is None:
            index = self.target_index

        return self._get_geom_at_index(index)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="losanalyst.classes.los_global.LoSGlobal"><code class="flex name class">
<span>class <span class="ident">LoSGlobal</span></span>
<span>(</span><span>points, observer_offset=0, target_offset=0, target_x=0, target_y=0, sampling_distance=None, use_curvature_corrections=True, refraction_coefficient=0.13)</span>
</code></dt>
<dd>
<section class="desc"><p>Class representing global LoS.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>LoS</code></dt>
<dd>the basic class for representation of LoS</dd>
</dl>
<p><code>Constructor of Los.</code></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>points</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>float</code></dt>
<dd>List of points that represents LoS. The structure is [[X1, Y1, Z1], [X2, Y2, Z2] &hellip; [Xn, Yn, Zn]].</dd>
<dt><strong><code>is_global</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is the LoS global?</dd>
<dt><strong><code>is_without_target</code></strong> :&ensp;<code>bool</code></dt>
<dd>Is the LoS without target?</dd>
<dt><strong><code>observer_offset</code></strong>, <strong><code>target_offset</code></strong> :&ensp;<code>float</code></dt>
<dd>Values representing offset of observer and target.</dd>
<dt><strong><code>target_x</code></strong>, <strong><code>target_y</code></strong> :&ensp;<code>float</code></dt>
<dd>Coordinates of the target point. Necessary for global LoS.</dd>
<dt><strong><code>sampling_distance</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Sampling distance on Los if it known. Otherwise it is estimated from <code>points</code>.</dd>
<dt><strong><code>use_curvature_corrections</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Calculate Earth curvature corrections while analyzing LoS. Default value is <code>True</code>.</dd>
<dt><strong><code>refraction_coefficient</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Refraction coefficient. Default value is <code>0.13</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LoSGlobal(LoS):
    &#34;&#34;&#34;
    Class representing global LoS.

    See Also
    --------
    LoS : the basic class for representation of LoS
    &#34;&#34;&#34;

    def __init__(self,
                 points: list,
                 observer_offset: float = 0,
                 target_offset: float = 0,
                 target_x: float = 0,
                 target_y: float = 0,
                 sampling_distance: float = None,
                 use_curvature_corrections: bool = True,
                 refraction_coefficient: float = 0.13):

        super().__init__(points,
                         is_global=True,
                         observer_offset=observer_offset,
                         target_offset=target_offset,
                         target_x=target_x,
                         target_y=target_y,
                         sampling_distance=sampling_distance,
                         use_curvature_corrections=use_curvature_corrections,
                         refraction_coefficient=refraction_coefficient)

        self.global_horizon_index = None

    def get_visible(self, return_integer: bool = False) -&gt; Union[bool, int]:
        &#34;&#34;&#34;
        Is the target point visible?

        Parameters
        ----------
        return_integer : bool, optional
            If the value is `True` returns values `0` or `1`. If it is `False` returns `True` or `False`.

        Returns
        -------
        bool or int
            Visibility of target point.
        &#34;&#34;&#34;

        if return_integer:
            return int(self.visible[self.target_index])
        else:
            return self.visible[self.target_index]

    def _get_global_horizon_index(self) -&gt; int:
        &#34;&#34;&#34;
        Returns index of global horizon from list of points.

        Returns
        -------
        int
            Index of global horizon in `points`. If `0` then no global horizon is found.
        &#34;&#34;&#34;

        if self.global_horizon_index is not None:
            return self.global_horizon_index
        else:
            horizon_index = 0
            for i in range(1, len(self.points) - 1):
                if self.horizon[i] and i != self.target_index:
                    horizon_index = i
            self.global_horizon_index = horizon_index
            return self.global_horizon_index

    def get_angle_difference_global_horizon(self) -&gt; float:
        &#34;&#34;&#34;
        Get angle difference between target point and horizon angle. Positive value means that horizon is lower than
        target point, negative value means that horizon is higher then target point.

        Returns
        -------
        float
            Value of angle difference.
        &#34;&#34;&#34;

        horizon_angle = -90
        if self._get_global_horizon_index() != 0:
            horizon_angle = self.points[self._get_global_horizon_index()][4]
        return self.points[self.target_index][4] - horizon_angle

    def get_elevation_difference_global_horizon(self) -&gt; float:
        &#34;&#34;&#34;
        Get elevation difference between target point and horizon angle. Positive value means that horizon is lower than
        target point and the resulting value have to be added to target point to hide the horizon. Negative value
        means that horizon is higher then target point and it would need to lower by resulting value not to hide the
        horizon.

        Returns
        -------
        float
        &#34;&#34;&#34;

        elev_difference_horizon = self.points[self.target_index][3] - (
                    self.points[0][3] + math.tan(math.radians(self.points[self._get_global_horizon_index()][4])) *
                    self.points[self.target_index][2])
        return elev_difference_horizon

    def get_horizon_distance(self) -&gt; float:
        &#34;&#34;&#34;
        Get distance of the global horizon from observer.

        Returns
        -------
        float
            Distance.
        &#34;&#34;&#34;
        return self.points[self._get_global_horizon_index()][2]

    def get_horizon_count(self) -&gt; int:
        &#34;&#34;&#34;
        Get the number of horizons behind target on LoS.

        Returns
        -------
        int
        &#34;&#34;&#34;
        return int(math.fsum(self.horizon[self.target_index+1:]))

    def __get_global_horizon_index(self) -&gt; int:
        &#34;&#34;&#34;
        Find the global horizon in `horizon`.

        Returns
        -------
        int
            Index in list.
        &#34;&#34;&#34;

        index = None

        for i in range(len(self.points) - 1, -1, -1):
            if self.horizon[i]:
                index = i
                break

        return index

    def get_global_horizon(self) -&gt; ogr.Geometry:
        &#34;&#34;&#34;
        Get global horizon from LoS as `ogr.Geometry` point.

        Returns
        -------
        ogr.Geometry
        &#34;&#34;&#34;
        index = self.__get_global_horizon_index()

        if index is None:
            index = -1

        return self._get_geom_at_index(index)

    def _get_max_local_horizon_index(self) -&gt; int:
        &#34;&#34;&#34;
        Get index of maximal local horizon (between observer and target) from `horizon`.

        Returns
        -------
        int or None
            If the result is `None`, there is no local horizon.
        &#34;&#34;&#34;

        index = None

        for i in range(self.target_index-1, -1, -1):
            if self.horizon[i] and i != self.target_index:
                index = i
                break

        return index

    def get_max_local_horizon(self) -&gt; ogr.Geometry:
        &#34;&#34;&#34;
        Get maximal local horizon from LoS as `ogr.Geometry` point.

        Returns
        -------
        ogr.Geometry
        &#34;&#34;&#34;
        index = self._get_max_local_horizon_index()

        if index is None:
            index = self.target_index

        return self._get_geom_at_index(index)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="losanalyst.classes.los.LoS" href="los.html#losanalyst.classes.los.LoS">LoS</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_angle_difference_global_horizon"><code class="name flex">
<span>def <span class="ident">get_angle_difference_global_horizon</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get angle difference between target point and horizon angle. Positive value means that horizon is lower than
target point, negative value means that horizon is higher then target point.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Value of angle difference.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_angle_difference_global_horizon(self) -&gt; float:
    &#34;&#34;&#34;
    Get angle difference between target point and horizon angle. Positive value means that horizon is lower than
    target point, negative value means that horizon is higher then target point.

    Returns
    -------
    float
        Value of angle difference.
    &#34;&#34;&#34;

    horizon_angle = -90
    if self._get_global_horizon_index() != 0:
        horizon_angle = self.points[self._get_global_horizon_index()][4]
    return self.points[self.target_index][4] - horizon_angle</code></pre>
</details>
</dd>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_elevation_difference_global_horizon"><code class="name flex">
<span>def <span class="ident">get_elevation_difference_global_horizon</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get elevation difference between target point and horizon angle. Positive value means that horizon is lower than
target point and the resulting value have to be added to target point to hide the horizon. Negative value
means that horizon is higher then target point and it would need to lower by resulting value not to hide the
horizon.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_elevation_difference_global_horizon(self) -&gt; float:
    &#34;&#34;&#34;
    Get elevation difference between target point and horizon angle. Positive value means that horizon is lower than
    target point and the resulting value have to be added to target point to hide the horizon. Negative value
    means that horizon is higher then target point and it would need to lower by resulting value not to hide the
    horizon.

    Returns
    -------
    float
    &#34;&#34;&#34;

    elev_difference_horizon = self.points[self.target_index][3] - (
                self.points[0][3] + math.tan(math.radians(self.points[self._get_global_horizon_index()][4])) *
                self.points[self.target_index][2])
    return elev_difference_horizon</code></pre>
</details>
</dd>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_global_horizon"><code class="name flex">
<span>def <span class="ident">get_global_horizon</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get global horizon from LoS as <code>ogr.Geometry</code> point.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ogr.Geometry</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_global_horizon(self) -&gt; ogr.Geometry:
    &#34;&#34;&#34;
    Get global horizon from LoS as `ogr.Geometry` point.

    Returns
    -------
    ogr.Geometry
    &#34;&#34;&#34;
    index = self.__get_global_horizon_index()

    if index is None:
        index = -1

    return self._get_geom_at_index(index)</code></pre>
</details>
</dd>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_horizon_count"><code class="name flex">
<span>def <span class="ident">get_horizon_count</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get the number of horizons behind target on LoS.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_horizon_count(self) -&gt; int:
    &#34;&#34;&#34;
    Get the number of horizons behind target on LoS.

    Returns
    -------
    int
    &#34;&#34;&#34;
    return int(math.fsum(self.horizon[self.target_index+1:]))</code></pre>
</details>
</dd>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_horizon_distance"><code class="name flex">
<span>def <span class="ident">get_horizon_distance</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get distance of the global horizon from observer.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Distance.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_horizon_distance(self) -&gt; float:
    &#34;&#34;&#34;
    Get distance of the global horizon from observer.

    Returns
    -------
    float
        Distance.
    &#34;&#34;&#34;
    return self.points[self._get_global_horizon_index()][2]</code></pre>
</details>
</dd>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_max_local_horizon"><code class="name flex">
<span>def <span class="ident">get_max_local_horizon</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Get maximal local horizon from LoS as <code>ogr.Geometry</code> point.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ogr.Geometry</code></dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_max_local_horizon(self) -&gt; ogr.Geometry:
    &#34;&#34;&#34;
    Get maximal local horizon from LoS as `ogr.Geometry` point.

    Returns
    -------
    ogr.Geometry
    &#34;&#34;&#34;
    index = self._get_max_local_horizon_index()

    if index is None:
        index = self.target_index

    return self._get_geom_at_index(index)</code></pre>
</details>
</dd>
<dt id="losanalyst.classes.los_global.LoSGlobal.get_visible"><code class="name flex">
<span>def <span class="ident">get_visible</span></span>(<span>self, return_integer=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Is the target point visible?</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>return_integer</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If the value is <code>True</code> returns values <code>0</code> or <code>1</code>. If it is <code>False</code> returns <code>True</code> or <code>False</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code> or <code>int</code></dt>
<dd>Visibility of target point.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_visible(self, return_integer: bool = False) -&gt; Union[bool, int]:
    &#34;&#34;&#34;
    Is the target point visible?

    Parameters
    ----------
    return_integer : bool, optional
        If the value is `True` returns values `0` or `1`. If it is `False` returns `True` or `False`.

    Returns
    -------
    bool or int
        Visibility of target point.
    &#34;&#34;&#34;

    if return_integer:
        return int(self.visible[self.target_index])
    else:
        return self.visible[self.target_index]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="losanalyst.classes.los.LoS" href="los.html#losanalyst.classes.los.LoS">LoS</a></b></code>:
<ul class="hlist">
<li><code><a title="losanalyst.classes.los.LoS.get_horizons" href="los.html#losanalyst.classes.los.LoS.get_horizons">get_horizons</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="losanalyst.classes" href="index.html">losanalyst.classes</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="losanalyst.classes.los_global.LoSGlobal" href="#losanalyst.classes.los_global.LoSGlobal">LoSGlobal</a></code></h4>
<ul class="">
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_angle_difference_global_horizon" href="#losanalyst.classes.los_global.LoSGlobal.get_angle_difference_global_horizon">get_angle_difference_global_horizon</a></code></li>
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_elevation_difference_global_horizon" href="#losanalyst.classes.los_global.LoSGlobal.get_elevation_difference_global_horizon">get_elevation_difference_global_horizon</a></code></li>
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_global_horizon" href="#losanalyst.classes.los_global.LoSGlobal.get_global_horizon">get_global_horizon</a></code></li>
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_horizon_count" href="#losanalyst.classes.los_global.LoSGlobal.get_horizon_count">get_horizon_count</a></code></li>
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_horizon_distance" href="#losanalyst.classes.los_global.LoSGlobal.get_horizon_distance">get_horizon_distance</a></code></li>
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_max_local_horizon" href="#losanalyst.classes.los_global.LoSGlobal.get_max_local_horizon">get_max_local_horizon</a></code></li>
<li><code><a title="losanalyst.classes.los_global.LoSGlobal.get_visible" href="#losanalyst.classes.los_global.LoSGlobal.get_visible">get_visible</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>